from typing import Dict, Any
from datetime import datetime, timedelta

from flask import Blueprint, request, jsonify
from flask_jwt_extended import jwt_required
from marshmallow import ValidationError
from sqlalchemy import func, desc, or_
from server.models.database import db
from server.models import (
    User,
    Product,
    Order,
    Category,
    UserRole,
    OrderStatus,
    PaymentStatus,
    OrderItem,
)
from server.schemas import AdminUserCreateSchema, PaginationSchema
from server.utils import success_response, error_response, admin_required, paginate_query

# Create blueprint WITHOUT url_prefix. Register with create_app(app) as:
# app.register_blueprint(admin_bp, url_prefix="/api/admin")
admin_bp = Blueprint("admin", __name__)


def _float_or_zero(v):
    return float(v or 0)


# -------------------------
# User management endpoints
# -------------------------
@admin_bp.route("/users", methods=["GET"])
@admin_required
def get_all_users():
    """
    GET /api/admin/users
    Return paginated list of users. Optional query params: page, per_page, role, is_active, search
    """
    try:
        schema = PaginationSchema()
        pagination_data = schema.load(request.args or {})

        query = User.query.order_by(User.created_at.desc())

        role = request.args.get("role")
        if role:
            try:
                query = query.filter(User.role == UserRole(role))
            except ValueError:
                return error_response("Invalid role value", 400)

        is_active = request.args.get("is_active")
        if is_active is not None:
            query = query.filter(User.is_active == (is_active.lower() == "true"))

        search = request.args.get("search")
        if search:
            s = f"%{search}%"
            query = query.filter(
                or_(
                    User.first_name.ilike(s),
                    User.last_name.ilike(s),
                    User.email.ilike(s),
                )
            )

        result = paginate_query(
            query,
            pagination_data.get("page", 1),
            pagination_data.get("per_page", 20),
        )

        users_data = [u.to_dict() for u in result["items"]]
        return success_response(
            "Users retrieved successfully",
            {"users": users_data, "pagination": result["pagination"]},
        )
    except ValidationError as ve:
        return error_response("Validation failed", 400, ve.messages)
    except Exception as e:
        return error_response(f"Failed to get users: {str(e)}", 500)


@admin_bp.route("/users", methods=["POST"])
@admin_required
def create_user():
    """
    POST /api/admin/users
    Create a new user (admin only).
    """
    try:
        schema = AdminUserCreateSchema()
        payload = schema.load(request.json or {})

        if User.query.filter_by(email=payload["email"]).first():
            return error_response("User with this email already exists", 409)

        user = User(
            email=payload["email"],
            first_name=payload["first_name"],
            last_name=payload["last_name"],
            phone=payload.get("phone"),
            role=UserRole(payload.get("role", "customer")),
        )
        user.set_password(payload["password"])

        db.session.add(user)
        db.session.commit()

        return success_response("User created successfully", user.to_dict(), 201)
    except ValidationError as ve:
        return error_response("Validation failed", 400, ve.messages)
    except Exception as e:
        db.session.rollback()
        return error_response(f"Failed to create user: {str(e)}", 500)


@admin_bp.route("/users/<int:user_id>", methods=["PUT"])
@admin_required
def update_user(user_id: int):
    """
    PUT /api/admin/users/<id>
    Update user fields (first_name, last_name, phone, is_active, role)
    """
    try:
        user = User.query.get(user_id)
        if not user:
            return error_response("User not found", 404)

        data = request.json or {}
        allowed_fields = {"first_name", "last_name", "phone", "is_active", "role"}

        for field, value in data.items():
            if field not in allowed_fields:
                continue
            if field == "role":
                try:
                    user.role = UserRole(value)
                except ValueError:
                    return error_response("Invalid role value", 400)
            else:
                setattr(user, field, value)

        db.session.commit()
        return success_response("User updated successfully", user.to_dict())
    except Exception as e:
        db.session.rollback()
        return error_response(f"Failed to update user: {str(e)}", 500)


@admin_bp.route("/users/<int:user_id>/toggle-status", methods=["PUT"])
@admin_required
def toggle_user_status(user_id: int):
    """
    PUT /api/admin/users/<id>/toggle-status
    Toggle is_active for a user
    """
    try:
        user = User.query.get(user_id)
        if not user:
            return error_response("User not found", 404)

        user.is_active = not bool(user.is_active)
        db.session.commit()
        status = "activated" if user.is_active else "deactivated"
        return success_response(f"User {status} successfully", user.to_dict())
    except Exception as e:
        db.session.rollback()
        return error_response(f"Failed to toggle user status: {str(e)}", 500)


# -------------------------
# Analytics endpoints
# -------------------------
@admin_bp.route("/analytics/dashboard", methods=["GET"])
@admin_required
def get_dashboard_analytics():
    """
    GET /api/admin/analytics/dashboard
    High level KPIs for admin dashboard
    """
    try:
        now = datetime.utcnow()
        thirty_days_ago = now - timedelta(days=30)
        seven_days_ago = now - timedelta(days=7)
        yesterday = now - timedelta(days=1)

        # Users
        total_users = User.query.count()
        active_users = User.query.filter_by(is_active=True).count()
        new_users_30d = User.query.filter(User.created_at >= thirty_days_ago).count()
        new_users_7d = User.query.filter(User.created_at >= seven_days_ago).count()

        # Products
        total_products = Product.query.count()
        active_products = Product.query.filter_by(is_active=True).count()
        featured_products = Product.query.filter_by(is_featured=True, is_active=True).count()
        out_of_stock = Product.query.filter_by(is_active=True).filter(Product.stock_quantity == 0).count()

        # Orders
        total_orders = Order.query.count()
        orders_30d = Order.query.filter(Order.created_at >= thirty_days_ago).count()
        orders_7d = Order.query.filter(Order.created_at >= seven_days_ago).count()
        orders_today = Order.query.filter(Order.created_at >= yesterday).count()

        pending_orders = Order.query.filter_by(status=OrderStatus.PENDING).count()
        processing_orders = Order.query.filter_by(status=OrderStatus.PROCESSING).count()
        shipped_orders = Order.query.filter_by(status=OrderStatus.SHIPPED).count()

        # Revenue
        total_revenue = (
            db.session.query(func.sum(Order.total_amount))
            .filter(Order.payment_status == PaymentStatus.COMPLETED)
            .scalar()
            or 0
        )
        revenue_30d = (
            db.session.query(func.sum(Order.total_amount))
            .filter(Order.created_at >= thirty_days_ago, Order.payment_status == PaymentStatus.COMPLETED)
            .scalar()
            or 0
        )
        revenue_7d = (
            db.session.query(func.sum(Order.total_amount))
            .filter(Order.created_at >= seven_days_ago, Order.payment_status == PaymentStatus.COMPLETED)
            .scalar()
            or 0
        )
        pending_revenue = (
            db.session.query(func.sum(Order.total_amount))
            .filter(Order.payment_status == PaymentStatus.PENDING)
            .scalar()
            or 0
        )

        # Categories
        total_categories = Category.query.count()
        active_categories = Category.query.filter_by(is_active=True).count()

        analytics = {
            "users": {"total": total_users, "active": active_users, "new_30d": new_users_30d, "new_7d": new_users_7d},
            "products": {
                "total": total_products,
                "active": active_products,
                "featured": featured_products,
                "out_of_stock": out_of_stock,
            },
            "orders": {
                "total": total_orders,
                "orders_30d": orders_30d,
                "orders_7d": orders_7d,
                "orders_today": orders_today,
                "pending": pending_orders,
                "processing": processing_orders,
                "shipped": shipped_orders,
            },
            "revenue": {
                "total": _float_or_zero(total_revenue),
                "revenue_30d": _float_or_zero(revenue_30d),
                "revenue_7d": _float_or_zero(revenue_7d),
                "pending": _float_or_zero(pending_revenue),
            },
            "categories": {"total": total_categories, "active": active_categories},
        }

        return success_response("Dashboard analytics retrieved successfully", analytics)
    except Exception as e:
        return error_response(f"Failed to get dashboard analytics: {str(e)}", 500)


@admin_bp.route("/analytics/products", methods=["GET"])
@admin_required
def get_product_analytics():
    """
    GET /api/admin/analytics/products
    Product-level analytics (top sellers, most viewed, low stock, by category)
    """
    try:
        top_selling = (
            Product.query.with_entities(Product.id, Product.name, Product.sales_count, Product.stock_quantity, Product.price)
            .filter_by(is_active=True)
            .order_by(desc(Product.sales_count))
            .limit(10)
            .all()
        )

        most_viewed = (
            Product.query.with_entities(Product.id, Product.name, Product.views_count, Product.sales_count, Product.price)
            .filter_by(is_active=True)
            .order_by(desc(Product.views_count))
            .limit(10)
            .all()
        )

        low_stock = (
            Product.query.with_entities(Product.id, Product.name, Product.stock_quantity, Product.sales_count)
            .filter(Product.is_active == True, Product.stock_quantity <= 10)
            .order_by(Product.stock_quantity)
            .all()
        )

        products_by_category = (
            db.session.query(Category.name.label("category"), func.count(Product.id).label("product_count"), func.sum(Product.sales_count).label("total_sales"))
            .join(Product, Product.category_id == Category.id)
            .filter(Product.is_active == True)
            .group_by(Category.name)
            .all()
        )

        analytics = {
            "top_selling": [
                {"id": p.id, "name": p.name, "sales_count": p.sales_count, "stock_quantity": p.stock_quantity, "price": _float_or_zero(p.price)}
                for p in top_selling
            ],
            "most_viewed": [
                {"id": p.id, "name": p.name, "views_count": p.views_count, "sales_count": p.sales_count, "price": _float_or_zero(p.price)}
                for p in most_viewed
            ],
            "low_stock": [
                {"id": p.id, "name": p.name, "stock_quantity": p.stock_quantity, "sales_count": p.sales_count}
                for p in low_stock
            ],
            "by_category": [
                {"category": cat.category, "product_count": int(cat.product_count or 0), "total_sales": int(cat.total_sales or 0)}
                for cat in products_by_category
            ],
        }

        return success_response("Product analytics retrieved successfully", analytics)
    except Exception as e:
        return error_response(f"Failed to get product analytics: {str(e)}", 500)


@admin_bp.route("/analytics/orders", methods=["GET"])
@admin_required
def get_order_analytics():
    """
    GET /api/admin/analytics/orders
    Order analytics: status breakdown, payment breakdown, daily orders, average order value, top customers
    """
    try:
        now = datetime.utcnow()
        thirty_days_ago = now - timedelta(days=30)

        order_status_counts = db.session.query(Order.status, func.count(Order.id).label("count")).group_by(Order.status).all()
        payment_status_counts = db.session.query(Order.payment_status, func.count(Order.id).label("count")).group_by(Order.payment_status).all()

        daily_orders = (
            db.session.query(func.date(Order.created_at).label("date"), func.count(Order.id).label("order_count"), func.sum(Order.total_amount).label("revenue"))
            .filter(Order.created_at >= thirty_days_ago)
            .group_by(func.date(Order.created_at))
            .order_by(func.date(Order.created_at))
            .all()
        )

        avg_order_value = db.session.query(func.avg(Order.total_amount)).scalar() or 0

        top_customers = (
            db.session.query(User.id, User.first_name, User.last_name, User.email, func.count(Order.id).label("order_count"), func.sum(Order.total_amount).label("total_spent"))
            .join(Order, Order.user_id == User.id)
            .group_by(User.id)
            .order_by(desc(func.count(Order.id)))
            .limit(10)
            .all()
        )

        analytics = {
            "order_status": [{"status": s[0].value if hasattr(s[0], "value") else str(s[0]), "count": s[1]} for s in order_status_counts],
            "payment_status": [{"status": p[0].value if hasattr(p[0], "value") else str(p[0]), "count": p[1]} for p in payment_status_counts],
            "daily_orders": [{"date": d.date.isoformat(), "order_count": d.order_count, "revenue": _float_or_zero(d.revenue)} for d in daily_orders],
            "avg_order_value": _float_or_zero(avg_order_value),
            "top_customers": [
                {"id": c.id, "name": f"{c.first_name} {c.last_name}", "email": c.email, "order_count": c.order_count, "total_spent": _float_or_zero(c.total_spent)}
                for c in top_customers
            ],
        }

        return success_response("Order analytics retrieved successfully", analytics)
    except Exception as e:
        return error_response(f"Failed to get order analytics: {str(e)}", 500)


@admin_bp.route("/analytics/revenue", methods=["GET"])
@admin_required
def get_revenue_analytics():
    """
    GET /api/admin/analytics/revenue
    Revenue trends and by-category metrics
    """
    try:
        now = datetime.utcnow()
        current_year = now.year
        current_month = now.month

        monthly_revenue = (
            db.session.query(func.extract("month", Order.created_at).label("month"), func.sum(Order.total_amount).label("revenue"), func.count(Order.id).label("order_count"))
            .filter(func.extract("year", Order.created_at) == current_year, Order.payment_status == PaymentStatus.COMPLETED)
            .group_by(func.extract("month", Order.created_at))
            .all()
        )

        revenue_by_category = (
            db.session.query(Category.name, func.sum(OrderItem.total_price).label("revenue"))
            .join(Product, Product.category_id == Category.id)
            .join(OrderItem, OrderItem.product_id == Product.id)
            .join(Order, OrderItem.order_id == Order.id)
            .filter(Order.payment_status == PaymentStatus.COMPLETED)
            .group_by(Category.name)
            .all()
        )

        last_month = current_month - 1 if current_month > 1 else 12
        last_month_year = current_year if current_month > 1 else current_year - 1

        current_month_revenue = (
            db.session.query(func.sum(Order.total_amount))
            .filter(func.extract("year", Order.created_at) == current_year, func.extract("month", Order.created_at) == current_month, Order.payment_status == PaymentStatus.COMPLETED)
            .scalar()
            or 0
        )
        last_month_revenue = (
            db.session.query(func.sum(Order.total_amount))
            .filter(func.extract("year", Order.created_at) == last_month_year, func.extract("month", Order.created_at) == last_month, Order.payment_status == PaymentStatus.COMPLETED)
            .scalar()
            or 0
        )

        growth_rate = 0.0
        if last_month_revenue > 0:
            growth_rate = ((current_month_revenue - last_month_revenue) / last_month_revenue) * 100

        analytics = {
            "monthly_revenue": [{"month": int(m.month), "revenue": _float_or_zero(m.revenue), "order_count": m.order_count} for m in monthly_revenue],
            "revenue_by_category": [{"category": r[0], "revenue": _float_or_zero(r[1])} for r in revenue_by_category],
            "current_month_revenue": _float_or_zero(current_month_revenue),
            "last_month_revenue": _float_or_zero(last_month_revenue),
            "growth_rate": round(growth_rate, 2),
        }

        return success_response("Revenue analytics retrieved successfully", analytics)
    except Exception as e:
        return error_response(f"Failed to get revenue analytics: {str(e)}", 500)