from typing import Dict, Any
from flask import Blueprint, request
from flask_jwt_extended import jwt_required, get_jwt_identity
from marshmallow import ValidationError
from sqlalchemy import or_, and_
from server.models.database import db, Product, Category
from server.schemas import ProductCreateSchema, ProductUpdateSchema, ProductFilterSchema
from server.utils import (
    success_response,
    error_response,
    admin_required,
    paginate_query,
    generate_sku,
)

products_bp = Blueprint("products", __name__, url_prefix="/api/products")


# ------------------------
# Public product endpoints
# ------------------------
@products_bp.route("", methods=["GET"])
def get_products():
    """Get all products with filtering and pagination"""
    try:
        schema = ProductFilterSchema()
        filters = schema.load(request.args or {})

        query = Product.query.filter_by(is_active=True)

        # Apply filters
        if filters.get("category_id"):
            query = query.filter_by(category_id=filters["category_id"])

        if filters.get("brand"):
            query = query.filter_by(brand=filters["brand"])

        if filters.get("min_price"):
            query = query.filter(Product.price >= filters["min_price"])

        if filters.get("max_price"):
            query = query.filter(Product.price <= filters["max_price"])

        if filters.get("in_stock"):
            query = query.filter(Product.stock_quantity > 0)

        if filters.get("featured"):
            query = query.filter_by(is_featured=True)

        if filters.get("search"):
            search_term = f"%{filters['search']}%"
            query = query.filter(
                or_(
                    Product.name.ilike(search_term),
                    Product.description.ilike(search_term),
                    Product.brand.ilike(search_term),
                )
            )

        # Apply sorting
        sort_by = filters.get("sort_by", "created_at")
        sort_order = filters.get("sort_order", "asc")

        if hasattr(Product, sort_by):
            order_column = getattr(Product, sort_by)
            if sort_order == "desc":
                query = query.order_by(order_column.desc())
            else:
                query = query.order_by(order_column.asc())

        # Paginate results
        result = paginate_query(query, filters.get("page", 1), filters.get("per_page", 20))
        products_data = [product.to_dict() for product in result["items"]]

        return success_response(
            "Products retrieved successfully",
            {"products": products_data, "pagination": result["pagination"]},
        )

    except ValidationError as e:
        return error_response("Validation failed", 400, e.messages)
    except Exception as e:
        return error_response(f"Failed to get products: {str(e)}", 500)


@products_bp.route("/<int:product_id>", methods=["GET"])
def get_product(product_id: int):
    """Get single product by ID"""
    try:
        product = Product.query.filter_by(id=product_id, is_active=True).first()
        if not product:
            return error_response("Product not found", 404)

        # Increment views count
        try:
            product.views_count = (product.views_count or 0) + 1
            db.session.commit()
        except Exception:
            # Don't fail the request if increment fails; rollback and continue
            db.session.rollback()

        return success_response("Product retrieved successfully", product.to_dict())

    except Exception as e:
        return error_response(f"Failed to get product: {str(e)}", 500)


@products_bp.route("/featured", methods=["GET"])
def get_featured_products():
    """Get featured products"""
    try:
        products = Product.query.filter_by(is_featured=True, is_active=True).limit(12).all()
        products_data = [product.to_dict() for product in products]
        return success_response("Featured products retrieved successfully", products_data)
    except Exception as e:
        return error_response(f"Failed to get featured products: {str(e)}", 500)


@products_bp.route("/categories/<int:category_id>", methods=["GET"])
def get_products_by_category(category_id: int):
    """Get products by category"""
    try:
        category = Category.query.filter_by(id=category_id, is_active=True).first()
        if not category:
            return error_response("Category not found", 404)

        schema = ProductFilterSchema()
        filters = schema.load(request.args or {})

        query = Product.query.filter_by(category_id=category_id, is_active=True)

        # Apply additional filters
        if filters.get("brand"):
            query = query.filter_by(brand=filters["brand"])

        if filters.get("min_price"):
            query = query.filter(Product.price >= filters["min_price"])

        if filters.get("max_price"):
            query = query.filter(Product.price <= filters["max_price"])

        if filters.get("in_stock"):
            query = query.filter(Product.stock_quantity > 0)

        # Apply sorting
        sort_by = filters.get("sort_by", "created_at")
        sort_order = filters.get("sort_order", "asc")

        if hasattr(Product, sort_by):
            order_column = getattr(Product, sort_by)
            if sort_order == "desc":
                query = query.order_by(order_column.desc())
            else:
                query = query.order_by(order_column.asc())

        # Paginate results
        result = paginate_query(query, filters.get("page", 1), filters.get("per_page", 20))
        products_data = [product.to_dict() for product in result["items"]]

        return success_response(
            f"Products in {category.name} retrieved successfully",
            {"category": category.to_dict(), "products": products_data, "pagination": result["pagination"]},
        )

    except ValidationError as e:
        return error_response("Validation failed", 400, e.messages)
    except Exception as e:
        return error_response(f"Failed to get products by category: {str(e)}", 500)


@products_bp.route("/search", methods=["GET"])
def search_products():
    """Search products"""
    try:
        search_term = request.args.get("q", "").strip()
        if not search_term:
            return error_response("Search term is required", 400)

        # Pagination
        page = request.args.get("page", 1, type=int)
        per_page = min(request.args.get("per_page", 20, type=int), 100)

        # Build search query
        search_pattern = f"%{search_term}%"
        query = Product.query.filter(
            and_(
                Product.is_active == True,
                or_(
                    Product.name.ilike(search_pattern),
                    Product.description.ilike(search_pattern),
                    Product.brand.ilike(search_pattern),
                    Product.model.ilike(search_pattern),
                ),
            )
        )

        # Optional filters
        category_id = request.args.get("category_id", type=int)
        if category_id:
            query = query.filter_by(category_id=category_id)

        brand = request.args.get("brand")
        if brand:
            query = query.filter_by(brand=brand)

        min_price = request.args.get("min_price", type=float)
        if min_price:
            query = query.filter(Product.price >= min_price)

        max_price = request.args.get("max_price", type=float)
        if max_price:
            query = query.filter(Product.price <= max_price)

        # Sorting
        sort_by = request.args.get("sort_by", "created_at")
        sort_order = request.args.get("sort_order", "desc")

        if hasattr(Product, sort_by):
            order_column = getattr(Product, sort_by)
            if sort_order == "desc":
                query = query.order_by(order_column.desc())
            else:
                query = query.order_by(order_column.asc())

        # Paginate
        result = paginate_query(query, page, per_page)
        products_data = [product.to_dict() for product in result["items"]]

        return success_response(
            f'Search results for "{search_term}"',
            {"search_term": search_term, "products": products_data, "pagination": result["pagination"]},
        )

    except Exception as e:
        return error_response(f"Failed to search products: {str(e)}", 500)


# ------------------------
# Admin product endpoints
# ------------------------
@products_bp.route("", methods=["POST"])
@jwt_required()
@admin_required
def create_product():
    """Create a new product (Admin only)"""
    try:
        schema = ProductCreateSchema()
        data = schema.load(request.json or {})

        # Check category exists
        category = Category.query.get(data["category_id"])
        if not category:
            return error_response("Category not found", 404)

        # Check SKU uniqueness if provided
        if data.get("sku") and Product.query.filter_by(sku=data["sku"]).first():
            return error_response("SKU already exists", 409)

        # Set SKU if not provided
        if not data.get("sku"):
            data["sku"] = generate_sku()

        product = Product(**data)
        db.session.add(product)
        db.session.commit()

        return success_response("Product created successfully", product.to_dict(), 201)
    except ValidationError as e:
        return error_response("Validation failed", 400, e.messages)
    except Exception as e:
        db.session.rollback()
        return error_response(f"Failed to create product: {str(e)}", 500)


@products_bp.route("/<int:product_id>", methods=["PUT", "PATCH"])
@jwt_required()
@admin_required
def update_product(product_id: int):
    """Admin-only: update product (partial or full)."""
    try:
        product = Product.query.get(product_id)
        if not product:
            return error_response("Product not found", 404)

        schema = ProductUpdateSchema()
        data = schema.load(request.json or {})

        # If category_id provided, verify exists
        if "category_id" in data:
            category = Category.query.get(data["category_id"])
            if not category:
                return error_response("Category not found", 404)

        # Apply allowed updates
        changed = False
        for field, value in data.items():
            if hasattr(product, field):
                setattr(product, field, value)
                changed = True

        if not changed:
            return error_response("No valid fields provided for update", 400)

        db.session.commit()
        return success_response("Product updated successfully", product.to_dict()), 200

    except ValidationError as ve:
        return error_response("Validation failed", 400, ve.messages)
    except Exception as e:
        db.session.rollback()
        return error_response(f"Failed to update product: {str(e)}", 500)


@products_bp.route("/<int:product_id>", methods=["DELETE"])
@jwt_required()
@admin_required
def delete_product(product_id: int):
    """Admin-only: delete product (soft delete)."""
    try:
        product = Product.query.get(product_id)
        if not product:
            return error_response("Product not found", 404)

        # Soft delete
        product.is_active = False
        db.session.commit()

        return success_response("Product deleted successfully"), 200
    except Exception as e:
        db.session.rollback()
        return error_response(f"Failed to delete product: {str(e)}", 500)